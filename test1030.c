#define _CRT_SECURE_NO_WARNINGS 1
//#include<stdio.h>
//#include<string.h>
//int main()
//{
//	                   //strlen 是求字符串长度的函数 需要有头文件<string.h>
//	char arr[]= "ABC"; //arr字符数组里面默认就已经有了一个\0
//	char arr1[] = {'a','b','c','\0'}; //sizeof在计算arr1所占用内存的时候，\0也是占用一个char即 4个char类型的数据，即4 * char = 4
//	printf("%d\n",strlen(arr)); //strlne计算的是字符数组arr里面的统计A,B,C直到统计到\0就不再统计了并且不会计算\0所以呢arr字符数组只有3个
//	printf("%d\n",sizeof(arr)); //sizeof是求取字符数组arr在内存中占用的空间 即 3个char 3 *char =3，就是3个字节
//	printf("%d\n",strlen(arr1)); //strlen在计算字符数组arr1时统计到字符c之后没有\0结束标志，strlen会一直统计下去直到遇到\0才会停止，
//	                            //这里只会出现一个随机值。如果在字符串里面加上一个\0那么就可以直接得到一个长度3，因为strlen在统计的时候遇到\0时就停止统计，计算值为3
//	                            //因为字符串结束标志为\0,当然\0和是一样的效果，\0这个转义字符就是0，但最好是使用\0，因为我们知道\0是字符串结束标志
//	printf("%d\n",sizeof(arr1)); //sizeof求取arr1数组在内存中占用空间 即 3个char 3 * char = 3 就是3个字节
//	return 0;
//}
//数据类型有两种，类置类型 char short int  long ,long long float double l；自定义类型
//类型意义 a 使用类型开辟的内存空间大小（大小决定了使用范围) b 如何看待内存空间的视角
//整型家族 char unsigned char 和 signed char 
//         short， unsigned short
// 浮点型 单，双精度类型 float double 类型
// 构造类型(自定义类型)  数组类型 结构体类型 枚举类型 联合体类型 
// 指针类型  int* p char* pc float *pf void *pv

#include<stdio.h>
//
//
//int main()
//{
//	int a = 10;
//	float f = 10.0;
//	return 0;
//
//}					
//原码 反码 补码 计算机中整型有符号数字三种表现形式
// 三种方法均为有符号位和数值位 符号位是0则表示正数 1表示是负
//整数（这里只有符数才会这样转变）首先进行十进制转换成二进制 得到原码 再将原码符号位不变 
//其它位取反 得到反码 然后反码+1 得到补码（反过来可以得到原码） 
//注意的是正整数的原码 反码 补码都一样 不需要讨论 编译器规定就是这样 的
// 得到补码后 计算机内部存储的是二进制序列的补码 编译器调试时看到的是二进制转成16进制2 
//printf打印的标准打印 打印的是十进制 c规定打印的结果为十进制
//当我们打印某个整型数值时，编译器是经过了十进制转二进制，再经过二进制位运算后得到结果，而这个
//同样还是二进制序列 编译器再经过printf函数经行标准打印 得到的就是我们知道的十进制数值
//在计算机系统中 整型数值一律用补码来标是和存储 ，使用补码可以将符号位和数值域统一处理 
//同时也可以统一处理加法和减法（cpu只做加法运算） 此外 补码和原码相互转换 其运算过程是
// 相同的，不需要额外的硬件电路・
//
int main()
{
	int a = 20;
	// 原码 0000 0000 0000 0000 0000 0000 0001 0100
	// 反码 0000 0000 0000 0000 0000 0000 0001 0100
	// 补码 0000 0000 0000 0000 0000 0000 0001 0100
// 十六进制    0   0   0     0   0     0   1    4
	// 正整数的原，反 补 一样 
	//20的十六进制标是形式为 0x00000014
	int b = -10;
	//原码 1000 0000 0000 0000 0000 0000 0000 1010
	// 1是符号位 
	// 符号位不变 其他位取反
	//反码 1111 1111 1111 1111 1111 1111 1111 0101
  //原码加1 得到反码 
// 反码加1 得到补码
// 补码  1111 1111 1111 1111 1111 1111 1111 0110
// 16进制      f     f     f    f    f    f    f    6
//-10十六进制标是位0xfffffff6
	return 0;
	//这里的a= 20；在内存中存储的是14 00 00 00 是用小端存储
	//大端存储模式 是指数据的低位保存在内存的高地址中，而数据的高位保存在内存的低地址中
	//小端存储模式 是指数据的地位保存在内存的低地址中，而数据的高位保存在内存的高地址中
}//  大端    数据低地址――>内存高地址          数据高地址――>内存低地址
//  小端   数据地地址 ――> 内存低地址       数据高地址――>内存高地址


